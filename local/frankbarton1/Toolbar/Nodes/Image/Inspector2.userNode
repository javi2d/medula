
#brain.Lib.script = sop.sh.Lib.script()

Class = 'Group'


#NODE.label = '<font size=10 color="green">INSPECTOR</font></p>'


class Script_Inspector:
	
	inspect_script_history  = bttnKnob( '<b>script history</b>'  )
	inspect_render_history  = bttnKnob( '<b>render history</b>'  )

	
	sep1     = sepKnob()
	
	path    = fileKnob( '' , '')
	
	pattern = strKnob( '' , '*.nk' )
	
	sep2     = sepKnob()
	
	
	recursive  = boolKnob( 'scan folder recursively' , True , flags = 'STARTLINE' )
	
	scan  = bttnKnob( '<b>SCAN</b>'  , flags = 'STARTLINE' )
	

	
	
	files   = enumKnob( '' , [ ' '*200 ] , clearflags = 'STARTLINE')
	
	load   = bttnKnob( '<b>L</b>' )
	
	prev    = bttnKnob( '<b>&#60;</b>' )
	next    = bttnKnob( '<b>&#62;</b>' )
	
	step    = intKnob( '' , 1 , clearflags = 'STARTLINE' )
	
	sep3     = sepKnob()
	
	last    = txtKnob( '' , ' ' )




def onCreate( this ):
	
	
	this.KNOBS.path.setValue( this.UNIT_PATH )
	

def pattern( this ):
	
	scan( this )

	if this.KNOBS.files.values():
    
		this.KNOBS.files.setValue( this.KNOBS.files.values()[-1] )



def inspect_script_history( this ):
	
	
	if this.SCRIPT_NAME:
		
		this.KNOBS.path.setValue( this.UNIT_PATH + '/nuke/_historyScripts/' )
		
		import re 
		
		matches = re.findall( "_v\d+" , this.SCRIPT_NAME , re.IGNORECASE)
		
		if matches:

			script_basename = this.SCRIPT_NAME.split( matches[0] )[0]
		
		else:
			
			script_basename = this.SCRIPT_NAME
		
		this.KNOBS.pattern.setValue( '*%s*.nk' % script_basename )
		
		this.KNOBS.recursive.setValue( True )
		
		scan( this )
		
		if this.KNOBS.files.values():
	    
			this.KNOBS.files.setValue( this.KNOBS.files.values()[-1] )
			
	else:
		
		nuke.message( 'The script must be saved to inspect script history' )
	


def inspect_render_history( this ):
	
	inspector_node = this.NODE

	nuke.Root().begin()

	selected_nodes = nuke.selectedNodes()

	nuke.Root().end()

	this = this( inspector_node )

	if len( selected_nodes ) == 1 and selected_nodes[0].Class() == 'Read':

		render_name = os.path.basename( selected_nodes[0]['file'].value() ).split('.')[0]
		
		this.KNOBS.path.setValue( this.UNIT_PATH + '/nuke/_renderScripts/' )
		
		this.KNOBS.pattern.setValue( '*%s.nk' % render_name )

		this.KNOBS.recursive.setValue( True )

		scan( this )

		if this.KNOBS.files.values():

			this.KNOBS.files.setValue( this.KNOBS.files.values()[-1] )

	else:
		
		nuke.message( 'Select a Read node and push "render history" button again to inspect the ReadÂ´s render history.' )
		




	


def scan( this ):
	

	base_path = sop.Normalize.path( this.VALUES.path )
	pattern   = sop.Normalize.path( this.VALUES.pattern )
	
	this.KNOBS.pattern.setValue( pattern )
	
	if base_path.endswith('/'):
		
		base_path = base_path[:-1]
		this.KNOBS.path.setValue( base_path )
	
	
	if pattern.startswith('/'):

		pattern = pattern[1:]
		this.KNOBS.pattern.setValue( pattern )
	

	all_matches = []

	import fnmatch

	for P,D,F in os.walk( base_path ):	
		
		matches = fnmatch.filter( F , pattern )
		
		rel_path = P.replace( base_path  , '' )
		
		all_matches.extend (  [ '...' + sop.Normalize.join( rel_path , m )  for m in matches ] )
			
		if not this.VALUES.recursive:

			break	
		
	
	if all_matches:
	
		this.KNOBS.files.setValues( all_matches )

		current_value = this.VALUES.files
		
		if current_value in all_matches:
		
			index = all_matches.index( current_value )
		
		else:
			
			index = len( all_matches )
		
		# prev and next implementation
		
		if this.KNOB == this.KNOBS.next:

			index += this.VALUES.step

			this.KNOBS.files.setValue( 0 if  index == len( all_matches )  else index  )


		elif this.KNOB == this.KNOBS.prev:

			index -= this.VALUES.step

			this.KNOBS.files.setValue( len( all_matches ) - 1  if index == -1  else index   )

		this.KNOBS.last.setValue( 'SCAN RESULT : %s files matching pattern' % len( all_matches ) )
		
		
	else:
		
		this.KNOBS.files.setValues([])
		
		this.KNOBS.last.setValue( 'WARNING: No matches with current pattern' )
		

	

def load_file( this ):
	
	path = sop.Normalize.join( this.VALUES.path , this.VALUES.files[4:]	)
	
	if this.PARENT.Class() == 'Root' and path:
		
		this.KNOBS.last.setValue( os.path.basename( path ) )
		
		this.NODE.begin()
		
		for node in this.NODE.nodes():
			
			nuke.delete( node )
	
		nuke.scriptReadFile( path )

		for node in this.NODE.nodes():
					
			if node.Class() == 'Viewer':
				
				node.setName( '%s_Viewer' % this.NODE.name() )
				
			if node.Class() == 'Group' and 'Script_Inspector' in node.knobs() :
				
				nuke.delete( node )
		

		allNodes = nuke.allNodes()
		
		bdX = -100 + min([node.xpos() for node in allNodes]) 
		bdY = -100 + min([node.ypos() for node in allNodes]) 
		bdW = 100 + max([node.xpos() + node.screenWidth() for node in allNodes]) - bdX 
		bdH = 100 + max([node.ypos() + node.screenHeight() for node in allNodes]) - bdY 
		
		
		import random
		
		color_range = range( 100 , 110 )
		
		hex_color = '%02x%02x%02x' % ( random.choice( color_range ) , random.choice( color_range ) , random.choice( color_range ) )
		
		tile_color = int( hex_color , 16 )
		
		n = nuke.nodes.BackdropNode(xpos = bdX, 
		                            bdwidth = bdW, 
		                            ypos = bdY, 
		                            bdheight = bdH, 
		                            tile_color = tile_color, 
		                            note_font_size=42)
		
	
		
		this.NODE.end()
		
		
		

def load( this ):
	
	scan( this )
	load_file( this )
	
	

def prev( this ):
	
	scan( this )
	load_file( this )


def next( this ):
	
	scan( this )
	load_file( this )





	


		
			


	
			
		