

TABS = [ 'Write.node', 'Write_Management_v08.tab'   ] #,  , 'Write_Task_Params_v02.tab' 

DEFAULTS = {

'channels' : 'all' ,


}





def onUserCreate( this ):

	# To use a write node the user is forced to save the script
	# This can be replaced with the Script

	if not this.SCRIPT_PATH : #nuke.tcl('value root.name'):

		brain.Lib.script.saveScript()






def beforeRender( this ):

	# Empty Write Connected directly to a read Node
	# Autoinject proxy name of the read node

	brain.total_render_time = time.time()

	read_node = this( NODE = this.NODE.input(0) )

	# Auto Proxy Write

	if read_node.NODE.Class() == 'Read' and read_node.VALUES.file:

		# Auto Write

		if not this.VALUES.file and not this.VALUES.proxy:	
			
			file_type = this.VALUES.file_type
			
			if file_type == ' ':
				
				print '>> PROXY AUTO WRITE for node [ %s ]' % this.NODE.name()

				#this.KNOBS.file.fromUserText( read_node.VALUES.file )

				if read_node.VALUES.proxy:			

					this.KNOBS.proxy.fromScript( '%s' % read_node.VALUES.proxy ) #this.KNOBS.proxy.fromUserText( read_node.VALUES.proxy )

					read_node.KNOBS.proxy.setValue( '' )

				else:
				
					this.KNOBS.proxy.fromScript( '%s' % brain.Lib.sequence.proxy_res_path( read_node.VALUES.file ) )
			
			else:
				
				ext = { 'targa' : 'tga' , 'jpeg' : 'jpg' }.get( file_type , None )  or file_type
				
				src_folder , src_basename  = os.path.split( read_node.VALUES.file )
				
				src_name , src_ext = os.path.splitext( src_basename )
				
				
				target_folder = this.VALUES.conv_target_folder or src_folder
				
				target_basename = src_name + '.CONVERSION.' + ext
				
				#if target_basename == src_basename  and  target_folder == src_folder: 
				
				target_path = Normalize.path( os.path.join(  target_folder  , target_basename ) )
				
				this.KNOBS.file.fromScript( target_path  )
				
				
					

		# Force Reproxy

		elif not this.VALUES.file and this.VALUES.proxy:

			if this.VALUES.proxy == read_node.VALUES.proxy:

				read_node.KNOBS.proxy.setValue( '' )

		# Regular Render

		else:

			print '>> REGULAR RENDER, DIRECTLY FROM A READ NODE'



	# get target render dirname based on Root.proxy mode

	if not this.ROOT.VALUES.proxy:

		dirname , basename = os.path.split( this.VALUES.file )

	else:

		dirname , basename = os.path.split( this.VALUES.proxy )


	# autocreate target render dirname

	if not os.path.exists( dirname ):

		sh( dirname )

		print '>> [ AUTO FOLDER CREATION ] : ' , dirname


	brain.Lib.mRender.append_render_output( this.NODE )

	brain.Lib.script.saveScript() # this will upgrade subversion, in fact render any node will update subversion

	if basename:

		# Only copy if target render exist

		render_name = basename.split('.')[0]
		brain.Lib.script.copyScript( '_renderScripts'  , script_name = render_name + '.nk' )

	print '>> [ ABOUT TO RENDER ] : %s node on %s script' % ( this.NODE.name() , os.path.basename( this.ROOT.VALUES.name) )



def afterFrameRender( this ):

	print 'Frame Rendered :  script = %s , node = %s , frame = %s ' % ( os.path.basename( this.ROOT.VALUES.name) , this.NODE.name() , nuke.frame() )


def afterRender( this ):

	# Recover proxy file in Read Node

	print '\n>> Rendered All Frames in %.3f seconds\n' %  ( time.time() - brain.total_render_time )


	read_node = this( NODE = this.NODE.input(0) )

	if read_node.NODE.Class() == 'Read' and not this.VALUES.file and not read_node.VALUES.proxy:

		print '>> PROXY AUTO WRITE pushing proxy path for node [ %s ]' % read_node.NODE.name()

		read_node.KNOBS.proxy.fromUserText( this.VALUES.proxy )


def inputChange( this ):

	this.KNOBS.autolabel.setValue( None )   # force autolabel callback


def autolabel( this ):


	input_node = this( NODE = this.NODE.input(0) )

	# Auto Proxy Write

	if input_node.NODE.Class() == 'Read' and input_node.VALUES.file:
		
		
		output = '%s\n\n' % this.NODE.name()
		
		if not this.VALUES.file and not this.VALUES.proxy:

			if this.VALUES.file_type == ' ':

				return  output + '(AUTO PROXY)\n' 

			else:

				return  output + '(AUTO CONVERSION TO %s)\n' % this.VALUES.file_type.upper()
		
		elif '.CONVERSION.' in this.VALUES.file:
			
			return  output + '%s\n\n(AUTO CONVERTED)\n' % os.path.basename( this.VALUES.file )
			
		elif '.PROXY.' in this.VALUES.proxy:
			
			return  output + '%s\n\n(AUTO GENERATED PROXY)\n' % os.path.basename( this.VALUES.proxy )
			
	
	else:

		return ''













