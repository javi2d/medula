
# this file is evaluated in main ( __main__ namespace )

import sys
try: sys.dont_write_bytecode = True
except: pass

#import sop_finder
import sop

"""
The sop module is the python implementation of the concept paradigm/dialect called Space Oriented Programming.

After sop is imported some variables are created into __main__ namespace:

	main : this is a reference of the __main__ namespace, same as doing import __main__ as main.

	brain : instance of sop.Brain , brains are used to store , share , dump and load data.

	sh : instance of sop.Shell pointing to folder where sop_finder is located.

	space : instance of sop.Space , this space is associated to this very file.


"""

#print sh.license['read']

"""
In this line

'sh' is a shell , with shells we can traverse through attributes our in disk folder structure. 
Think in shells as bookmarks to folders.

As said before 'sh' shell points to 'medula/system' folder ( where sop_finder.py is located )

however sh.license is a Space because it match a file ( medula/system/license.txt )

In this case sh.license and sh.license.txt will have the same result.

sh.license['read'] simply read the file the space is pointing to.


"""


# expose some handy shells

"""
sop.Expose.object( <obj> , <label> ) function exposes <obj> as <label> into 'main' and 'sop'

for example

sop.Expose.object( 100 , 'a' )

a == main.a == sop.a == 100

more info about exposing object later

"""

sop.Expose.object( sh( os.getcwd() ) , 'cwd' )

"""
sh( <path> ) , here we are calling a shell with a path as first argument

<path> could be an absolute path or a relative path ( relative to 'sh')

relative paths could have any number of dots like sh( '..../folder' )

If path points to a folder, a shell is returned. If path is a file a Space is returned

"""

sop.Expose.object( sh( '..' ) , 'medula' )

"""
This is a sample of relative path, 'medula' will be a shell to the parent folder of 'sh'

"""


if 'logs' not in medula['$FOLDER_NAMES']: brain.FIRST_RUN = True

"""
Another query for shells   <shell>['$FOLDER_NAMES'] , pretty obvious I hope. 

"""
	
sop.Expose.object( medula( 'logs' ) , 'logs' )

"""
Another shell defined to store startup logs, in this case we use previously created 'medula' shell

"""



sop.Expose.modules( 'nuke nukescripts shutil math threading' )
# modules are exposed in main and sop

"""
sop.Expose.modules is pretty similar to Expose.object but with modules.

Here the applied principle is 'import once, use everywhere'.

"""

brain.Lib << medula.system.Lib
# load medula system Lib folder into brain

"""
When we create an attribute in a brain ( brain.Lib ) with no data assignment ( brain.Lib = 100 ) another brain is created
automatically, in fact you can do this in one line:

brain.a.b.c.d.e.g = 100 and everything except 'g' will be brains. 

<brain> << <shell> means brain 'eat' shell's content 

Under medula.system.Lib there is a bunch of python files, these files ( Spaces ) are evaluated and eated by brain.Lib brain.


"""

medula.local( '_init.py' , write = '\nmedula.local.main._init()\n' )()
# execute user/local config.init


print 'DEBUG 111111'

sop.Core.lap( 'startup.medula.init' )
# start tag lapse 
sop.Core.output_redirect( logs( '%s.init.log' % this.HOSTLABEL )['file']  )
# redirect output to a log file


brain.Lib.include.LOAD_QUEUED_TOOLSETS()
# load all queued toolsets


sop.Core.output_restore( )
# restore output
sop.Core.lap( '/startup.medula.init' )
# stop tag lapse 

#sop.sys.exit()









