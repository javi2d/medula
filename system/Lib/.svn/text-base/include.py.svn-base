##
#print '\nDEBUG START EXEC FILE sh.Lib.include\n'


#import nuke
#import nukescripts



# This is one shot fixed file, reloaded on init

GUI_LOAD_Panels = []

GUI_LOAD_ViewerProcess = []

GUI_LOAD_Toolbars = []

GUI_LOAD_FavoriteDir = []

# include.TOOLSET



#brain.Lib( 'toolbar' , sh.Lib.toolbar() )




def _parse_shell_or_path( shell_or_path ):

	if type( shell_or_path ).__name__ == 'Shell':

		shell = shell_or_path

	else:

		shell = sh( shell_or_path )

	return shell



def LIB( shell_or_path ):

	shell = _parse_shell_or_path( shell_or_path )
	
	for lib_item in shell['$DIR']:
		
		print '>> Loading Lib item in memory : %s ' % lib_item 
		
		setattr( main.brain.Lib , lib_item , shell( '%s.py' % lib_item )() )
		
		
		
def SHELL( varname , shell_or_path ):
	
	shell = _parse_shell_or_path( shell_or_path )
	
	#new_shell = sh( path )
	
	setattr( main , varname , shell )
	setattr( main.sop , varname , shell )
	
	return shell


def TOOLSET( shell_or_path , varname = None  ,  recreate = False ):
	
	# Autocreate a ( widely available ) shell variable with this folder name
	
	shell = _parse_shell_or_path( shell_or_path )
	
	if varname:

		SHELL( varname , shell )
	
	
	shell( 'ts_begin.py' )()  # ( autocreate and )  evaluate init file space
	
	GUI_LOAD_FavoriteDir.append(  ( '%s' % shell['$NAME'] , shell['$PATH'] )  )
	
	if recreate:
		
		for name in 'Brain Commands Gizmos Lib Node Panel Template Toolbar Lib ViewerProcess'.split():
			
			shell( name )
			
		for name in [ 'Animation' , 'Axis' , 'Node Graph' , 'Nodes' , 'Nuke' , 'Pane' , 'Properties' , 'Viewer' ]:
			
			shell.Toolbar( name )
			
	
	
	#FOLDERS = [ os.path.basename( path ) for path in shell['$FOLDERS'] ]
	
	FOLDERS = shell['$FOLDER_NAMES']
	
	if 'Lib' in FOLDERS:
		
		LIB( shell.Lib )
	
	
	if 'Brain' in FOLDERS:
		       
		shell.Brain( 'Hotkeys.memory' ) # ( autocreate Hotkeys.memory file)
		
		for path in shell.Brain['$FILES']:  #

			dirname , basename = os.path.split( path )
			name, ext = os.path.splitext( basename )

			if ext == '.memory':

				brain( name , Brain() ) << sh( path )

				#setattr( brain.memo_files , name , path )  # saves path of memory file loaded
		
		
		
	if 'Node' in FOLDERS:            
		
		node_files = shell.Node['$FILES *.node']
		
		if node_files:
			
			for path in node_files:
								
				sh( path )()  # call node file , trigger nodeSolver

		#sh.Lib.nodes().processNodes(  shell.Node  )
		
		#space.GUI_LOAD_Toolbars.append( ( shell.Node , 'Nuke' ) )
	 
	   	
	if 'Panel' in FOLDERS:           
		
		space.GUI_LOAD_Panels.append( shell.Panel )
		space.GUI_LOAD_Toolbars.append( ( shell.Panel , 'Nuke' ) )

	if 'ViewerProcess' in FOLDERS:   
		
		space.GUI_LOAD_ViewerProcess.append( shell.ViewerProcess )
	
	if 'Template' in FOLDERS:   
		
		toolbar_recursive_pluginAddPath( shell.Template )
		space.GUI_LOAD_Toolbars.append( ( shell.Template , 'Nuke' ) )
	
	
	if 'Gizmos' in FOLDERS:

		toolbar_recursive_pluginAddPath( shell.Gizmos )

		space.GUI_LOAD_Toolbars.append( ( shell.Gizmos , 'Nodes' ) )

	if 'Commands' in FOLDERS:

		toolbar_recursive_pluginAddPath( shell.Commands )

		space.GUI_LOAD_Toolbars.append( ( shell.Commands , 'Nuke' ) )
	
	
	if 'Toolbar' in FOLDERS:
		
		#print 'CHECKPOINT 1' , shell.Toolbar.__path__
		
		toolbar_recursive_pluginAddPath( shell.Toolbar )
				
		space.GUI_LOAD_Toolbars.append( ( shell.Toolbar , None ) )
	
	
	
	registerUserNodes( shell )
	
	
	
	shell( 'ts_end.py' )()
	
		
# GUI RELATED FUNCTIONS ######################################################################	



def GUI_LOAD():
	
	if not brain( 'soft_reloads' , 0 ):
	
	
	
		nuke.removeFavoriteDir( '[ default_unit ]' )

		nuke.addFavoriteDir( '[ default_unit ]' , this.SESSIONS_UNIT_PATH )


		nuke.removeFavoriteDir( '[ current_unit ]' )

		nuke.addFavoriteDir( '[ current_unit ]' , this.UNIT_PATH + '/' )
	
		print '\nAdding Sources Favs:'
	
		for H , HN , R , LR , RR in brain.Lib.sources.walk():
		
			if this.HOSTNAME.lower() == HN.lower():
			
				paths = LR + RR
			
			else:
			
				paths = RR
			
			for path in paths:
			
				if os.path.isdir( path ) and os.listdir( path ):
				
					resource_label = '%s/%s' % ( H.lower() , R.upper() )
				
					print '\n    Alive resource %s = %s' % ( resource_label , path )

					nuke.removeFavoriteDir( resource_label )
				
					nuke.addFavoriteDir( resource_label , path + '/' )
	

		for label , path in GUI_LOAD_FavoriteDir:

		
			fav = '+ %s' % label
		
			print '\nAdding Toolset Fav: %s = %s ' % ( fav , path ) 
		
			nuke.removeFavoriteDir( fav )

			nuke.addFavoriteDir( fav , path )
	

	brain.soft_reloads += 1


	for shell in space.GUI_LOAD_Panels:

		print '\n>> Registering Panel Folder , %s' % shell.__path__ 

		registerPanels( shell._ )		

	for shell in space.GUI_LOAD_ViewerProcess:
		
		print '\n>> Registering ViewerProcess Folder , %s' % shell.__path__ 
		
		registerViewerProcess( shell )


	for shell , toolbar in space.GUI_LOAD_Toolbars:
		
		#print 'CHECKPOINT 2' , shell.__path__
		
		toolbar_addMenu(  shell , toolbar )
		
		
	#sys.stdout = nuke_stdout


	
def registerUserNodes( toolset_shell ):
	
	userNode_files = toolset_shell._['$FILES *.userNode'] + toolset_shell._['$FILES *.uNode']	
	
	for f in userNode_files:
		
		nbrain = brain.Lib.nodeScript.nodeBrain( f )

		brain.nodeScript( 'byNode' , { } )[ nbrain.name ] = nbrain
	


def registerPanels(  panels_shell ):
	
	panel_files = panels_shell['$FILES *.panel']

	for path in panel_files:
			
		brain.Lib.panel3.Static_Panel( path )
		
		
		
def registerViewerProcess(  viewerProcess_shell ):


	nuke.pluginAddPath( viewerProcess_shell.__path__ )

	files = viewerProcess_shell._['$FILES']

	for path in files:

		dirname, basename = os.path.split(path)
		name, ext = os.path.splitext( basename )

		print '      VP : %s' % basename

		#nuke.ViewerProcess.register( name , sh.Lib.viewerProcess().createViewerProcess , ( path , ) )
		
		nuke.ViewerProcess.register( name , createViewerProcess , ( path , ) )


def createViewerProcess( path ):

	dirname, basename = os.path.split(path)

	name, ext = os.path.splitext( basename )	

	if ext in ['.3dl','.csp','.cub','.cube','.vf','.vfz','.blut' ]:

		n = nuke.createNode( "Vectorfield" )

		n.knobs()['vfield_file'].setValue( path )

		Names = ['interpolation', 'gpuExtrapolate', 'colorspaceIn', 'colorspaceOut']

		for Value in main.brain.CONFIG( 'Luts%s' % ext , ['trilinear field' , True , 'linear' , 'linear'] ):

			name = Names.pop(0)
			n.knobs()[ name ].setValue( Value )

		return n

	elif ext in ['.gizmo']:

		n = nuke.createNode( basename )

		return n

	else:

		print 'File extension in ViewerProcess folder not matching'	
		
		
		
		
		
			

# MENU RELATED FUNCTIONS ######################################################################	


def _add_to_toolbar( shell_or_path , toolbar ):
	
	shell = _parse_shell_or_path( shell_or_path )
	
	toolbar_recursive_pluginAddPath( shell )
			
	space.GUI_LOAD_Toolbars.append( ( shell , toolbar ) )



class TOOLBAR:

	def ANIMATION( self, shell_or_path ): _add_to_toolbar( shell_or_path , 'Animation' )

	def AXIS( self , shell_or_path ): _add_to_toolbar( shell_or_path , 'Axis' )

	def NODE_GRAPH( self , shell_or_path ): _add_to_toolbar( shell_or_path , 'Node Graph' )

	def NODES( self, shell_or_path ): _add_to_toolbar( shell_or_path , 'Nodes' )

	def NUKE( self, shell_or_path ): _add_to_toolbar( shell_or_path , 'Nuke' )

	def PANE( self, shell_or_path ): _add_to_toolbar( shell_or_path , 'Pane' )

	def PROPERTIES( self, shell_or_path ): _add_to_toolbar( shell_or_path , 'Properties' )

	def VIEWER( self, shell_or_path ): _add_to_toolbar( shell_or_path , 'Viewer' )		
		
TOOLBAR = TOOLBAR()



# include.modules

def MODULES( modules = '' ):
	
	for name in modules.split(' '):
		
		if name:
			
			name = name.strip()
			
			try:
			
				module = __import__( name )
				setattr( main.sop , name , module )
			
			except ImportError:
				
				print '!!WARNING. Error importing [ %s ] Module ' % name 




# Old TOOLBAR.py FILE



def toolbar_recursive_pluginAddPath( Menu_shell ):

	'''
	Given a shell, add recursively all child folders to the nuke plugin path

	'''


	info = 'process Menu Folder for: %s' % Menu_shell.__path__

	#print '\n    >> %s' % info

	for folder in Menu_shell._.__all_folders__:

		nuke.pluginAddPath( folder )


	#print '    << %s' % info


def toolbar_addMenu( shll ,  toolbar = None):

	# Generate Menus

	print '\nShell >> Menu : %s\n' % shll['$NAME']


	bpaths = shll._.__bpaths__()

	for bpath in bpaths:  # shell.__path__, dir, dir, fname

		source_menu = _command2menuitem( bpath ,  toolbar = toolbar)

	#print '\n<< %s\n' % info


def _resolve_digit_start_names( name ):

	if name.startswith( '_' ):

		splitted_name = name.split('_')

		if splitted_name[1].isdigit() and len(splitted_name)>2:

			name = '_'.join( splitted_name[2:] )

	name = name.replace('_' , ' ').strip()

	return name





def _command2menuitem( bpath , toolbar = None ):

	'''


	'''

	icons = [ None ]

	def _check_icon_path( icon_path ):

		if not icon_path.endswith( '.png' ):

			icon_path += '.png'

		if os.path.exists( icon_path ):

			icons.append( icon_path )


	_check_icon_path( os.path.dirname( bpath[0] ) )

	_check_icon_path( bpath[0] )

	fullPath =  Normalize.join( *bpath ) # without extension

	cmd_name = bpath.pop() # last

	base_path = bpath.pop(0)

	if toolbar:

		base_path , base_name  = os.path.split( base_path )

		bpath = [ toolbar , base_name ] + bpath


	nuke_menu = bpath[0] 

	source_menu = nuke.menu( nuke_menu )

	_check_icon_path( Normalize.join( base_path , nuke_menu )  )

	#print '::' , base_path , bpath , cmd_name


	if source_menu:

		current_route_bpath = []

		current_path_bpath = []

		for sub_menu_name in bpath[1:]:

			# !NEW  using     def _resolve_digit_start_names( name ):

			current_route_bpath.append( _resolve_digit_start_names( sub_menu_name ) )
			current_path_bpath.append( sub_menu_name )


			current_route = '/'.join( current_route_bpath )

			if toolbar:

				#print '---with TOOLBAR : '  

				splitted_path = [ base_path ] + current_path_bpath


			else:

				#print '---with NO TOOLBAR : '  

				splitted_path = [ base_path ] + [ nuke_menu ] + current_path_bpath


			icon_path = Normalize.join( *splitted_path )

			#print 'SUB ICON PATH:' , icon_path


			_check_icon_path( icon_path )

			source_menu.addMenu( current_route  , icons[-1] )


		#print 'CMD ICON PATH:' , fullPath

		_check_icon_path( fullPath )	

		menuitem_name = cmd_name

		menuitem_name = _resolve_digit_start_names( menuitem_name )

		current_route_bpath.append( menuitem_name ) #cmd_name 


		route    = '/'.join( current_route_bpath )

		#cmd      = "sh('%s')._.%s()" % ( base_path , cmd_name ) # las intercarpetas no importan p q es un flat shell

		dirname , basename = os.path.split( fullPath )


		# .menu file support


		defaults = Brain() #<< defaults

		menu_file = os.path.splitext( fullPath )[0] + '.menu'

		if os.path.exists( menu_file ):

			defaults << sh( menu_file )




		label = defaults( 'label' , None )

		cmd = defaults( 'cmd' , "sh('%s').%s()" % ( dirname , basename )  )

		hotkey = defaults( 'hotkey' , brain.Hotkeys( cmd_name, None ) )

		icon = defaults( 'icon' , icons[-1] )

		#print '\n\nDEBUG icon_selected  :: ' , icon


		if label:

			menu_path , item_name = os.path.split( route )

			route =  '%s/%s' % ( menu_path , label )


		print '     >> %s/%s' % ( nuke_menu , route )

		source_menu.addCommand( route,cmd,hotkey,icon )


		return









