
def normalize( path ):
	
	return Normalize.path( path )


def join( *args ):

	return Normalize.join( *args )



def normalize_padding( path ):
	
	#path = brain.Lib.path.normalize( path )
	
	path = Normalize.path( path )
	
	dirname , basename = os.path.split( path )
	
	pad_count = basename.count('#')
	
	if pad_count:

		basename =  basename.replace( '#' * pad_count , '%' + ( '%02d' % pad_count ) + 'd' )
		
	
	return Normalize.join( dirname , basename )
	

def normalize_name( name ):
	
	normalized = ''

	for char in name:

		normalized += ( char if char.isalnum() else '_' )					

	if normalized and normalized[0].isdigit():

		normalized = '_' + normalized

	return normalized







def fragment( path  ):
	
	return  [ x for x in normalize( path ).split('/') ]
	


def head( path , start ):
	
	fragmented = fragment( path )
	
	if len( fragmented ) > start:
		
		return '/'.join( fragmented[:start] )
	
	else:
		
		return path
	

def tail( path , start ):
	
	fragmented = fragment( path )
	
	if len( fragmented ) > start:
		
		return '/'.join( fragmented[-start:] )
	
	else:
		
		return path



def isstill( path ):

	return ( False if '%' in normalize( path ) else True )

def issequence( path ):

	return ( True if '%' in normalize( path ) else False )


def iscomplete( path , firstFrame , lastFrame ):
	
	pass
		
		


def version( path ):

	path = brain.Lib.path.normalize( path )

	dirname , basename = os.path.split( path )

	version = 1

	for item in basename.split('_'):

		if item.startswith('v') and item[1:].isdigit():

			version = int( item[1:] )
			break

	return version



def proxy_from_file( file_value ):
	
	file_value = normalize_padding( file_value )

	dirname , basename = os.path.split( file_value )
	
	name , ext = os.path.splitext( basename )

	proxy_value = join(  dirname  , ( name + '.PROXY' + ext ) )
	
	return proxy_value


def valid_proxy_from_file( this ):
	
	proxy_value = proxy_from_file( this.VALUES.file )
	
	if '%' in proxy_value:
		
		if not os.path.exists( proxy_value % this.VALUES.first ):
		
			proxy_value = ''
	
	else:
		
		if not os.path.exists( proxy_value ):
		
			proxy_value = ''
	

	return proxy_value


def frame_path( path , frame ):

	path = brain.Lib.path.normalize_padding( path )

	if '%' in path:

		return path % frame

	else:

		return path


	


def autoproxy( this ):
	
	''' Fills proxy knob based on file knob if at least first proxy file  frame exists'''

	if this.CLASS == 'Read':
		
		proxy_value = proxy_from_file( this.VALUES.file )
		
		first_proxy_frame = frame_path( proxy_value , this.VALUES.first ) #first frame path
			
		if os.path.isfile( first_proxy_frame ):

			this.KNOBS.proxy.fromUserText( proxy_value )
		
		else:
			
			this.KNOBS.proxy.fromUserText( '' )
			
			
	
	else: # inclusive Write node 
		
		node_knobs = this.KNOBS['names']
		
		if 'file' in node_knobs and 'proxy' in node_knobs:
			
			proxy_value = proxy_from_file( this.VALUES.file )
			
			this.KNOBS.proxy.fromUserText( proxy_value )
		

	
	
def active_node_path( node ):
	
	# TODO return file or proxy values based on root.proxy state or return file if file is present or return None if node has not any file knob
	
	pass
	




def is_under( ref_path , path , use_cache = True ):
	
	compatible , match = brain.Lib.sources.compatible_match_cache( ref_path ) 
	
	for compatible in compatible:
		
		prefix = ref_path.replace( match , compatible )
		
		if path.upper().startswith( prefix.upper() ): 
			
			return True
	
	return False
	






def is_under_current_unit( path ):

	'''Get the unit path an get all the possible sources, if path starts with any of the possibilities is under unit'''
	
	return is_under( this.UNIT_PATH , path  )
	



def is_under_current_project( path ):

	
	return is_under( this.UNIT_PROJECT_PATH , path  )
	


def is_under_current_source( path ):
	
	if this.SCRIPT_PATH:

		script_host_resource = brain.Lib.sources.host_resource( this.SCRIPT_PATH )
		
		if script_host_resource and script_host_resource == brain.Lib.sources.host_resource( path ):
			
			return True


def is_under_current_host( path ):
	
	script_host_resource = brain.Lib.sources.host_resource( this.SCRIPT_PATH )
	
	path_host_resource = brain.Lib.sources.host_resource( path )
	
	
	if script_host_resource and path_host_resource and script_host_resource[0] == path_host_resource[0]:
		
		return True
	

def is_bound( path ):
	
	path_host_resource = brain.Lib.sources.host_resource( path )
	
	if path_host_resource:
		
		return True
	
	

	
	
def path_color( this ):
	
	colors = { 'green' : 1744785407 ,  'violet' : -881131521 , 'blue' : 1114505215 ,  'darkGrey' : 2054847231 , 'grey' : -960051457  }

	node_color = colors['grey']
	
	if this.NODE.Class() == 'Read':
		
		if this.VALUES.file and this.SCRIPT_PATH:	
		
			#print 'Color path : ' , brain.Lib.sources.host_resource( this.SCRIPT_PATH ) , is_under_current_unit( this.VALUES.file )
		
			if is_under_current_unit( this.VALUES.file ): 
			
				node_color = colors['green'] 

			elif is_under_current_host( this.VALUES.file ):
			
				node_color = colors['violet']
		
			elif is_bound( this.VALUES.file ):
			
				node_color = colors['blue']
						
			else:
			
				node_color = colors['darkGrey']

				

	return node_color



def colorize_node( node ):

	this = space.this( node )

	node_color = path_color( this )

	this.KNOBS.tile_color.setValue( node_color )

	
	
def auto_folders( sequence_path ):	
	
	dirname, basename = os.path.split( sequence_path )
	
	name = basename.split('.')[0].split('%')[0]
	
	name = ( name or os.path.basename( dirname )  )
	
	no_version = name
	
	import re 
	
	matches = re.findall( "_v\d+" , name , re.IGNORECASE)
	
	if matches:
		
		no_version = name.split( matches[-1] )[0]
	
	return name , no_version
	
	
	
	