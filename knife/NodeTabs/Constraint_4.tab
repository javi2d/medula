
# This tab files is part of LIBRARY/Nodes
# Written by Javier Garcia
# Third Rewrite 2010 javi2d@gmail.com

# Based on addconstraintab.py Written by Diogo Girondi , 
# derived from a TCL original by Frank Rueter and Broesler



class Constraint:
	
	#ytest = nuke.Boolean_Knob( 'ytest' )
	
	mode = enumKnob( 'mode' , ['disabled', 'enabled' , 'sticky mode', 'selected node'])
	
	sep = sepKnob('')
	

	family = enumKnob( '<p><font size="3" color="DeepSkyBlue">family</font></p>' , ['all'], clearflags = 'STARTLINE')
	update = bttnKnob( '<b><font size="1" color="yellowgreen">U</font></b>' )
	node = enumKnob( '<p><font size="3" color="orange">node</font></p>' ,['No Nodes'], clearflags = 'STARTLINE' )
	
	make_link = bttnKnob( 'make link')

	sep2 = sepKnob('')
	
	look_at = strKnob( 'Look At' )
	
	validate = txtKnob( '' , 'D' , clearflags = 'STARTLINE' )

	sep3 = sepKnob('')
	
	old_value = xyzKnob( 'old_value' , flags = 'INVISIBLE'  )
	
	constraint_mix = floatKnob( 'mix' , 1.0 )
	


#def onUserCreate( this ):
#	
#
#	sys.__stdout__.write( '1.on user create\n' )


#def onCreate( this ):
	

def _update_camera_knobs( this ):
	
	print 'Updating Camera Knobs...'
	
	values = ['all'] + this.NODES_BY_CLASS['names']
	this.KNOBS.family.setValues(  values  )
	
	if this.VALUES.family == 'all':

		Values = this.NODES['names']
		this.KNOBS.node.setValues( Values )

	else:

		Values = [ n.name() for n in this.NODES_BY_CLASS( this.VALUES.family , [] ) ]
		this.KNOBS.node.setValues( Values )
		
	if this.VALUES.family not in this.KNOBS.family.values():
		
		this.KNOBS.family.setValue( 0 )
	
	if this.VALUES.node not in this.KNOBS.node.values():

		this.KNOBS.node.setValue( 0 )
	



def family( this ):
			
	_update_camera_knobs( this ) #onCreate( this )


def update( this ):

	_update_camera_knobs( this ) #onCreate( this )
		
	
def make_link( this ):
	

	target =  nuke.toNode( this.VALUES.node )

	if target:
		
		_activate( this , target , target.fullName() )
	
	
	
def mode( this ):
	
	if type( this.KNOBS.look_at ).__name__ == 'Brain':
		
		# This avoid run this callback when no knobs have been created yet	
		
		return

	value = this.VALUES.mode
	
	if value == 'disabled':
		
		this.KNOBS.look_at.setEnabled( False )
		look_at( this )
		

	elif value == 'selected node':

		n = nuke.selectedNode()
		_activate( this , n , n.fullName() )
		
		
	elif value == 'enabled':
		
		
		target = nuke.toNode( this.VALUES.look_at )
		
		
		if target:
			
			_activate( this , target , this.VALUES.look_at )
		
	elif value == 'sticky mode':
	
		brain.COMPUTE_ALL_KNOBS = True
			


def _activate( this , node , value ):
	
	if this.NODE == node:
		
		this.KNOBS.look_at.setEnabled( False )
		look_at( this )
		
		this.KNOBS.mode.setValue( 'disabled' )
		
	else:
		
		this.KNOBS.look_at.setEnabled( True )
		this.KNOBS.look_at.setValue( value )
		
		look_at( this )
		
		this.KNOBS.mode.setValue( 'enabled' )

	
def look_at( this ):
	
	target = nuke.toNode( this.VALUES.look_at )
	
	is_enabled = this.KNOBS.look_at.enabled()
	
	if is_enabled:
		
				
		if target:

			fullName = target.fullName()
			this.KNOBS.validate.setValue('OK')
		
			add_expression( this )
			
		else:

			this.KNOBS.validate.setValue('ERROR')

			clear_expression( this )
		
			this.KNOBS.mode.setValue( 'disabled' )
			
			
	else:
		
		# Esto da problemas pq borra las animaciones con las que viene la camara
		# Debemos guardar el valor original para restaurarlo, en el caso que el valor no sea la expresion
		# En el caso que el valor sea la expresion se quedaran los valores actuales de la expresion
		
		clear_expression( this )



# EXPRESSION RELATED




def add_expression( this ):

	look_at_Value = this.VALUES.look_at

	broute = look_at_Value.split('.')
	
	if len( look_at_Value.split('.') ) == 1:

		this.KNOBS.look_at.setValue( 'root.' + look_at_Value )

	rotx = 'degrees(atan2($TN.translate.y-translate.y,sqrt(pow($TN.translate.x-translate.x,2)+pow($TN.translate.z-translate.z,2))))'.replace( '$TN' , this.VALUES.look_at ) #*constraint_mix+curve*(1-constraint_mix)
	roty = '$TN.translate.z-this.translate.z >= 0 ? 180+degrees(atan2($TN.translate.x-translate.x,$TN.translate.z-translate.z)) : 180+degrees(atan2($TN.translate.x-translate.x,$TN.translate.z-translate.z))'.replace( '$TN' , this.VALUES.look_at )   #*constraint_mix+curve*(1-constraint_mix)


	this.KNOBS.rotate.setExpression( rotx , 0)
	this.KNOBS.rotate.setExpression( roty , 1)	

	#print 'Added Expression'


def clear_expression( this ):

	#print repr( this.KNOBS.rotate )

	this.KNOBS.rotate.clearAnimated( 0 )
	this.KNOBS.rotate.clearAnimated( 1 )

	#print 'Removed Expression'





def nearest_node( this ):

	posx = this.VALUES.xpos
	posy = this.VALUES.ypos
	
	thresold = 100
	

	nodes = [ n for n in nuke.allNodes() if not n == this.NODE ]
		
	nodes = [ n for n in nodes if n['xpos'].value() > ( posx - thresold ) and n['xpos'].value() < ( posx + thresold ) ]
	nodes = [ n for n in nodes if n['ypos'].value() > ( posy - thresold ) and n['ypos'].value() < ( posy + thresold ) ]
	
	#print nodes
	
	distances = []
	
	for node in nodes:
       
		px = node['xpos'].value() - this.VALUES.xpos
		py = node['ypos'].value() - this.VALUES.ypos
       
		d = math.sqrt( px*px + py*py )
		
		distances.append( (d,node) )
       
	
	if distances:
	
		distance , nearest_node = sorted( distances )[0]
       
		#print distance , repr( nearest_node )
       
		if distance < 30:
       		
			brain.COMPUTE_ALL_KNOBS = False

			this.KNOBS.mode.setValue('enabled')
			this.KNOBS.look_at.setEnabled( True )
			this.KNOBS.look_at.setValue( nearest_node.fullName() )
			look_at( this )
			
			
			



def xpos( this ):
	
	if this.VALUES.mode == 'sticky mode':
	
		nearest_node( this )
		
		


def ypos( this ):
	
	if this.VALUES.mode == 'sticky mode':
		
		nearest_node( this )


		
		
		
	
	
	
	
