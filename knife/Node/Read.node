


class References:
	
	auto_proxy = boolKnob( 'auto find proxy file' , True , flags = 'STARTLINE' )
	
	sep = sepKnob()
		
	switch_source_ref = bttnKnob( 'switch src ref' , flags = 'STARTLINE' )
	source_reference = fileKnob( '' , '' , clearflags = 'STARTLINE' )
	
	create_target_ref = bttnKnob( 'create trg ref' , flags = 'STARTLINE' )
	target_reference = fileKnob( '' , '' , clearflags = 'STARTLINE' )
	
	sep2 = sepKnob()
	
	make_green  = bttnKnob( 'make green' , flags = 'STARTLINE' )
	
	find_proxy  = bttnKnob( 'find proxy' )
	

def switch_source_ref( this ):

	if this.VALUES.source_reference:
		
		src_value   = this.VALUES.source_reference
		file_value  = this.VALUES.file

		this.KNOBS.source_reference.fromUserText( file_value )
		this.KNOBS.file.fromUserText( '%s %s-%s' % ( src_value , this.VALUES.first , this.VALUES.last ) )
	
	#this.NODE.redraw()
	
	space.file( this )


def make_green( this ):

	nuke.message( 'Not Implemented : Use NodeGraph/knife_makeGreen/make_green ' )


def colorize_node( this ):
	
	#print 'COLORIZING NODE'
	
	seq_color = brain.Lib.sequence.color( this.VALUES.file )
	
	#print 'COLORIZING NODE' , seq_color
	
	this.KNOBS.tile_color.setValue( seq_color )
	
	this.NODE.redraw()


def target_reference( this ):
	
	print 'Target REF Modified'	


def onUserCreate( this ):
	
	if not this.ROOT.NODE.format().name():
		
		this.ROOT.KNOBS.format.setValue( this.NODE.format().name() )

	

def onCreate( this ):
	
	#print '> On Create'
	
	colorize_node( this )  #colorize_node( this )

	#print '<'
	

def file( this ):
	
	value = brain.Lib.path.normalize_padding( this.VALUES.file )
	
	if value:
	
		this.KNOBS.file.setValue( value  )

		if this.VALUES( 'auto_proxy' , None ):
		
			name = this.VALUES.file.split('.')[0].split('%')[0]
		
			proxy_name = brain.Lib.sequence.current_proxy_res_path( this )
			
			this.KNOBS.proxy.setValue( proxy_name )

	
	colorize_node( this )  #colorize_node( this )
	

def find_proxy( this ):
	
	file( this )



# Up version and down version triggers this callbacks
	
def autolabel( this ):
	
	label = '<center>%s' % this.NODE.name()
	
	
	if this.VALUES.target_reference:
		
		label += '<b><font color="Orange" size=7 >*</font></b>\n'
	
	else:
		
		label += '\n'
		
	#label += '%sx%s\n' % ( this.NODE.width() , this.NODE.height() )
	
	file_metadata = this.NODE.metadata('input/filename' , nuke.frame() )
	
	basename_font = '<font color="Black" size=4>%s</font>\n'
		
	label += basename_font % os.path.basename( this.VALUES.file  )

	label += '<b><font color="Black" size=5 >%s</font></b>\n' % ( 1 + this.NODE.lastFrame() - this.NODE.firstFrame() )
	
	#brain.Lib.sources = sh.Lib.sources()
	
	#print 'DEBUG RELOADED SOURCES'
	
	H,R = brain.Lib.sources.host_resource(  this.VALUES.file ) 
	
	#print 'DEBUG AUTOLABEL' , H,R
	
	if H and R:
		
		#host_resource = [ x.upper() for x in host_resource ]
		
		label += '%s/%s\n' % ( H ,R ) #( H.upper() ,R.upper() ) 
    
	else:
    
		label += 'UNBOUND\n'
	
	
	label +=  this.VALUES.colorspace
	
	return label
		






	

	
	
	


