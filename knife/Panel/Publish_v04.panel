
# This panel allow to publish footage to a target path
# TODO 


LABEL_TEMPLATE = '<font>%s</font>'

CONFIRM_TEMPLATE = '<font color="lightgreen">%s</font>'



class User:
	
	presets = enumKnob( 'preset' , [ '...' ]  )
	
	tmpl_preset_name = strKnob( '' , '' , clearflags = 'STARTLINE' )
	
	preset_dump = bttnKnob( '<font color="LightGreen">%s</font>' % '+' )
	
	preset_erase = bttnKnob( '<font color="LightGreen">%s</font>' % '-' )
	
	tmpl_target_folder = fileKnob( 'target' , '' )
	
	sep2 = sepKnob( ' ' )
	
	tmpl_date = boolKnob( 'date' , False )
	
	tmpl_folderize = boolKnob( 'auto_folder' , True )
	
	tmpl_folderize_mov = boolKnob( 'folderize movs' , False )
	
	tmpl_per_version = boolKnob( 'per version' , True )
	
	tmpl_overwrite = boolKnob( 'overwrite' , False )
	
	sep3 = sepKnob( ' ' )
	
	publish  = bttnKnob( LABEL_TEMPLATE % 'publish' , flags = 'STARTLINE')
	
	confirm = bttnKnob( CONFIRM_TEMPLATE % 'confirm' , flags = 'INVISIBLE')
	cancel = bttnKnob( '<font color="Red">cancel</font>' , flags = 'INVISIBLE')

	get_target_ref = bttnKnob( LABEL_TEMPLATE % 'get target reference' )


def _get_template( this ):

	writeKnobs = this.PANEL_NBRAIN.dynamic_bundle[1].writeKnobs( nuke.WRITE_ALL | nuke.TO_VALUE | nuke.TO_SCRIPT )

	template = '\n'.join( [ l for l in writeKnobs.split('\n') if l.startswith( 'tmpl_' ) ] )
	
	return template



def _apply_template( this ):
	
	preset_name = this.VALUES.presets 
	
	if not preset_name == '...':
		
		if preset_name in brain.Publish_v04['names']:
	
			template = brain.Publish_v04( preset_name )
			this.PANEL_NBRAIN.dynamic_bundle[1].readKnobs( template )
	
		else:
	
			raise RuntimeError( 'no preset name in brain.Publish_v04' )
		


	
def onCreate( this  ):
	
	#brain.Publish_v04 << local._user( 'Brain/Publish_v04.memory' )
	
	this.KNOBS.presets.setValues( ['...'] + brain.Publish_v04['names'] )
	

def knobChanged( this ):
	
	if this.KNOB.name().startswith( 'tmpl_' ) and not brain.Publish_v04( '__template_apply' , False ) :
		
		this.KNOBS.presets.setValue( 0 ) 


def tmpl_preset_name( this ):
	
	knob = this.KNOBS.tmpl_preset_name
	
	knob.setValue( Normalize.name( knob.value() ) )

	
def tmpl_target_folder( this ):

	knob = this.KNOBS.tmpl_target_folder

	knob.setValue( Normalize.path( knob.value() ) )	
	

def preset_dump( this ):
	
	preset_name = this.VALUES.tmpl_preset_name

	if this.VALUES.tmpl_preset_name:
		
		template = _get_template( this )
		
		print template
		
		brain.Publish_v04 << local._user.Brain( 'Publish_v04.memory' )
		
		brain.Publish_v04( this.VALUES.tmpl_preset_name , template , replace_att = True )

		brain.Publish_v04 >> local._user.Brain( 'Publish_v04.memory' )
	
	onCreate( this ) 
	
	this.KNOBS.presets.setValue( preset_name ) 
	
		
def preset_erase( this ):
	
	preset_name = this.VALUES.presets 
	
	if not preset_name == '...':
	
		delattr( brain.Publish_v04 , preset_name )
		
		print brain.Publish_v04
		
		brain.Publish_v04 >> local._user.Brain( 'Publish_v04.memory' )
	
		this.KNOBS.presets.setValue( 0 ) 
	
	else:
		
		print '\n\nINFO : to delete a preset select one from "preset" .'
	
	
	onCreate( this ) 
		
		
def presets( this ):
	
	brain.Publish_v04.__template_apply = True
	
	_apply_template( this )
		
	brain.Publish_v04.__template_apply = False


	
def get_target_ref( this ):
	
	for n in [ n for n in nuke.selectedNodes() if n.Class() == 'Read' ]:
		
		this_node = this( n )
		
		params = ( this_node.VALUES.target_reference , this_node.VALUES.first , this_node.VALUES.last )
		
		target_ref = nuke.createNode( 'Read' , 'file "%s %s-%s"' %  params , inpanel = False)
		
		target_ref.setXYpos( this_node.VALUES.xpos + 50 , this_node.VALUES.ypos + 50  )



def publish( this ):
	
	def publish_thread( this ):
	
		copy_queue = []
	
		for n in [ n for n in nuke.selectedNodes() if n.Class() == 'Read' ]:
			
			this_node =  this( n )
			
			file_value = this_node.VALUES.file  
			
			if file_value:
				
				file_value = brain.Lib.path.normalize_padding( file_value ) 			

				output_folder = _output_folder( this , file_value )
				
				basename = os.path.basename( file_value )

				target_value = Normalize.join( output_folder , basename )
					
				if '%' not in file_value:
					
					if os.path.exists( file_value ):
					
						copy_queue.append(  ( this_node , file_value , target_value ) )
				
				else:
					
					bad_frames = 0
					
					for i in range( this_node.VALUES.first , this_node.VALUES.last + 1  ):
						
						src_filename = file_value % i
						
						if os.path.exists( src_filename ):
							
							copy_queue.append(  ( this_node, src_filename , target_value % i ) )
						
						else:
							
							bad_frames += 1
					
					if bad_frames:
					
						print '\nWARNING %s bad frame/s in node [ %s ]' % ( bad_frames , n.name() )
			
			
		taskbar = nuke.ProgressTask( 'Publishing ...' )
		
		import shutil
		import filecmp
	
		total_items = len( copy_queue )
		
		current_item = 0
		
		
		print '\n>> Publish start with %s files to copy.' % len( copy_queue )
		
		applied_target_ref = [] 
			
		while copy_queue:
			
			if taskbar.isCancelled():	
				return
			
			this_node , src_path , trg_path = copy_queue.pop( 0 )
			
			
			node_name = this_node.NODE.name()
			
			if node_name not in applied_target_ref:
				
				this_node.KNOBS.target_reference.setValue( Normalize.join( os.path.dirname( trg_path ) , os.path.basename( this_node.VALUES.file ) ) )

			
			current_item += 1
			
			taskbar.setProgress( current_item*100/total_items )

			taskbar_message = '[ %s ] $$ .../%s' % ( node_name , brain.Lib.path.tail( trg_path , 1 )  )

			do_copy = False
			
			if os.path.exists( trg_path ):
				

				
				same_file =  os.stat( src_path )[2:-1] == os.stat( trg_path )[2:-1]   #filecmp.cmp( src_path , trg_path )
				
				if not same_file:
					
					print src_path #os.stat( src_path )[2:-1]
					print trg_path #os.stat( trg_path )[2:-1]
				
				
				if same_file and this.VALUES.tmpl_overwrite: # Modificated date
					
					do_copy = True
					
					taskbar_message = taskbar_message.replace( ' $$ ' , ' => ' )
				
				elif not same_file:
					
					do_copy = True
					
					taskbar_message = taskbar_message.replace( ' $$ ' , ' >> ' )
					
				else:
					
					do_copy = False
					
					taskbar_message = taskbar_message.replace( ' $$ ' , ' == ' )
				
				
				print same_file , taskbar_message 
				
				
			else:
				
				do_copy = True
				
				taskbar_message = taskbar_message.replace( ' $$ ' , ' >> ' )
				
				print taskbar_message 
				
				
			taskbar.setMessage( taskbar_message )
			
			
			
			if do_copy:
				
				sh( os.path.dirname( trg_path) )
				
				shutil.copy2( src_path , trg_path )
			
	
	
		
	import threading

	threading.Thread( None , publish_thread , args = ( this( this.NODE ) ,  ) ).start()
	


def _output_folder( this , file_value ):
	
	output_folder = this.VALUES.tmpl_target_folder
	
	if this.VALUES.tmpl_date:
		
		output_folder = Normalize.join( output_folder , Core.date() )
		
	

	ext = os.path.splitext( file_value )[-1]
	

	if ext.lower() in [ '.mov' ] :
		
		if this.VALUES.tmpl_folderize_mov:
			
			if this.VALUES.tmpl_per_version:

				output_folder += '/%s' %  brain.Lib.sequence.folder_with_version( file_value )

			else:

				output_folder += '/%s' %  brain.Lib.sequence.folder_without_version( file_value )
		

	else:
	
	
		if this.VALUES.tmpl_folderize:
		
			if this.VALUES.tmpl_per_version:
			
				output_folder += '/%s' %  brain.Lib.sequence.folder_with_version( file_value )#with_version
		
			else:
			
				output_folder += '/%s' %  brain.Lib.sequence.folder_without_version( file_value )#no_version
			
	return output_folder
				
